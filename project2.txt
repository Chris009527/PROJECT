#include <iostream>
#include <fstream>
#include <string>
#include <list>
#include <vector>
#include <queue>
#include<stack>
using namespace std;
struct Cood{
    int x,y;
    Cood(){}
    Cood(int a,int b){
        x = a;
        y = b;
    }
    Cood(const Cood& p){
        x = p.x;
        y = p.y;
    }
    bool operator == (const Cood& p){
       return(x == p.x && y == p.y);
    }
    Cood operator +(const Cood& p){
        return Cood(x+p.x,y+p.y);
    }
    Cood operator -(const Cood& p){
       return Cood(x-p.x,y-p.y);
    }
    bool operator != (const Cood& p){
       return(x != p.x || y != p.y);
    }
};
//////////////////////////////////////COOD
int **A;
int **w;
int **dis;
Cood**predecessor;
int n, m ,B;
bool found;
const Cood Up(-1,0),Down(1,0),Left(0,-1),Right(0,1);
int all_clear;
queue<Cood>ans;
int step = 0;
class path{
public:
    path(){
        rec_p.x = 0; rec_p.y = 0;
        now_p.x = 0; now_p.y = 0;
        battery = 0;
    };
    path(Cood R,int B){
        rec_p.x = R.x; rec_p.y = R.y ;
        now_p.x = R.x; now_p.y = R.y;
        battery = B;
    };
    int legalroad(Cood,Cood );
    void walk(Cood );
    void findw( );
    void shortest_dis(Cood);
    Cood get_p();
    void recharge();
private:
    Cood now_p;
    int battery;
    Cood rec_p;
    Cood return_p;

};
int main(int argc, char* argv[]){
    int n, m,B;
    ifstream fin;
    ofstream fout;
    string id = "106000212";
    string Inname("floor.data");
    string Outname("final.path");
    fin.open(Inname);
    fout.open(Outname);
    if(fin&&fout){
        cout<<"successful open "<<id+"/floor.data"<<endl;
        cout<<"successful open "<<id+"/final.path"<<endl;
    }else{
        if(!fin&&fout) cout<<"fail input "<<id+"/floor.data"<<endl;
        else if(fin&&!fout) cout<<"fail output "<<id+"/final.path"<<endl;
        else cout<<"fail both "<<id+"/floor.data"<<" and "<<id+"/final.path"<<endl;

        return -1;
    }
fin>>n>>m;
    fin>>B;
////////////////////////////////////////////////
    A = new int*[n];
    for(int i=1;i<=n;i++){
        A[i] = new int[m];
    }
    w = new int*[n];
    for(int i=1;i<=n;i++){
        w[i] = new int[m];
    }
    dis = new int*[n];
    for(int i=1;i<=n;i++){
        dis[i] = new int[m];
    }
    predecessor = new Cood*[n];
    for(int i=1;i<=n;i++){
        predecessor[i] = new Cood[m];
    }
///////////////////////////////////////////////
    Cood R;
    all_clear = 0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            char input;
            dis[i][j]=10000001;
            fin >> input;
            if(input == '1'){
                A[i][j]=1;
                w[i][j]=10000001;
            }else if(input == 'R'){
                A[i][j]=2;
                w[i][j]=1;
                dis[i][j] = 0;
                R.x = i;
                R.y = j;
            }else if(input == '0'){
                A[i][j]=0;
                w[i][j]=0;
                all_clear = all_clear+1;
            }
        }
    }
    path test(R,B);

    if(test.get_p().x==R.x&&test.get_p().y==R.y){
        cout<<"successful create"<<endl<<"rec_p is at:"<<R.x<<" "<<R.y<<endl;
    }else
        cout<<"fail "<<endl;

    test.findw();
/////////////////////////////////show dis
   /* cout<<"dis:"<<endl;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(dis[i][j] == 1000001) cout<<"X"<<" ";
            else cout<<dis[i][j]<<" ";
        }cout<<endl;
    }*/
///////////////////////////////////////
    fout<<ans.size()<<endl;
    for(int i=1; i<=step; i++){
        fout<<ans.front().x<<" "<<ans.front().y<<endl;
        ans.pop();
    }
////////////////////////////////////////////////////////////////////////////
    for(int i=1;i<=n;i++){
        delete[]A[m];
        delete[]w[m];
        delete[]dis[m];
        delete[]predecessor[m];
    }
    delete[]A;
    delete[]w;
    delete[]dis;
    delete[]predecessor;
///////////////////////////////////////////////////////////////////////////
return 0;

}    
//////////////////////////////


void path::walk(Cood dir){
    now_p = now_p + dir;
    if(w[now_p.x][now_p.y] == 0){
        all_clear = all_clear-1;
    }
    w[now_p.x][now_p.y] = w[now_p.x][now_p.y]+ 1;
    ans.push(Cood(now_p.x,now_p.y));
    battery = battery-1;
    step = step+1;
}
Cood path::get_p(){
    return now_p;
}




Cood searchR(int **mat){
    Cood R;
    int n,m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(mat[i][j] == 82){
                R.x = i;
                R.y = j;
                return R;
            }
        }
     }
queue<Cood> road;

int bfs(int sx, int sy, int ex, int ey,int **A){///找出兩點最短距離
    memset(book,0,sizeof(book));
    while(!road.empty())
        road.pop();
    Cood now,next;
    now.x=sx, now.y=sy, now.count=0;
    road.push(now);
    book[sx][sy]=1;
    while(!road.empty()){
        now=road.front();
        road.pop();
        for(int i=0;i<4;i++){
            next.x=now.x+d[i][0];
            next.y=now.y+d[i][1];
            next.count=now.count+1;
            if(A[next.x][next.y]==1) continue;
            if(next.x==ex && next.y==ey){
                cout<<next.count<<endl;
                return next.count;
            }
            else{
                book[next.x][next.y]=1;
                road.push(next);
            }
        }
    }
    return -1;
}
queue<Cood> droad;
void dfs(int x, int len,int**way){
    for(int i=0;i<=l;i++){
        if(vis[i]==0 && way[x][i] ){
            vis[i]=1;
            dfs(i,len+way[x][i],way);
            vis[i]=0;
        }
    }
}}
